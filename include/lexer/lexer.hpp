#pragma once

#include <boost/regex.hpp>

enum class Token {
    // strict keywords
    kAs,
    kBreak,
    kConst,
    kContinue,
    kCrate,
    kElse,
    kEnum,
    kFalse,
    kFn,
    kFor,
    kIf,
    kImpl,
    kIn,
    kLet,
    kLoop,
    kMatch,
    kMod,
    kMove,
    kMut,
    // kPub, do not need to implement
    kRef,
    kReturn,
    kSelf, // self
    kSelf_, // Self
    kStatic,
    kStruct,
    kSuper,
    kTrait,
    kTrue,
    kType,
    kUnsafe,
    kUse,
    kWhere,
    kWhile,
    kDyn,

    // identifier
    kIdentifier,

    // comments
    kComment,

    // literals
    kCharLiteral,
    kStringLiteral,
    kRawStringLiteral,
    kCStringLiteral,
    kRawCStringLiteral,
    kIntegerLiteral,

    // punctuations
    kPlus,
    kMinus,
    kStar,
    kSlash,
    kPercent,
    kCaret,
    kNot,
    kAnd,
    kOr,
    kAndAnd,
    kOrOr,
    kShl,
    kShr,
    kPlusEq,
    kMinusEq,
    kStarEq,
    kSlashEq,
    kPercentEq,
    kCaretEq,
    kAndEq,
    kOrEq,
    kShlEq,
    kShrEq,
    kEq,
    kEqEq,
    kNe,
    kGt,
    kLt,
    kGe,
    kLe,
    kAt,
    kUnderscore,
    kDot,
    kDotDot,
    kDotDotDot,
    kDotDotEq,
    kComma,
    kSemi,
    kColon,
    kPathSep,
    kRArrow,
    kFatArrow,
    kLArrow,
    kPound,
    kDollar,
    kQuestion,
    kTilde,

    // delimiters
    kLCurly,
    kRCurly,
    kLSquare,
    kRSquare,
    kLParenthese,
    kRParenthese,

    kEOF,
};

class Lexer {
private:
    std::vector<std::pair<Token, boost::regex>> patterns = {
        {Token::kAs, boost::regex("as")},
        {Token::kBreak, boost::regex("break")},
        {Token::kConst, boost::regex("const")},
        {Token::kContinue, boost::regex("continue")},
        {Token::kCrate, boost::regex("crate")},
        {Token::kElse, boost::regex("else")},
        {Token::kEnum, boost::regex("enum")},
        {Token::kFalse, boost::regex("false")},
        {Token::kFn, boost::regex("fn")},
        {Token::kFor, boost::regex("for")},
        {Token::kIf, boost::regex("if")},
        {Token::kImpl, boost::regex("impl")},
        {Token::kIn, boost::regex("in")},
        {Token::kLet, boost::regex("let")},
        {Token::kLoop, boost::regex("loop")},
        {Token::kMatch, boost::regex("match")},
        {Token::kMod, boost::regex("mod")},
        {Token::kMove, boost::regex("move")},
        {Token::kMut, boost::regex("mut")},
        {Token::kRef, boost::regex("ref")},
        {Token::kReturn, boost::regex("return")},
        {Token::kSelf, boost::regex("self")},
        {Token::kSelf_, boost::regex("Self")},
        {Token::kStatic, boost::regex("static")},
        {Token::kStruct, boost::regex("struct")},
        {Token::kSuper, boost::regex("super")},
        {Token::kTrait, boost::regex("trait")},
        {Token::kTrue, boost::regex("true")},
        {Token::kType, boost::regex("type")},
        {Token::kUnsafe, boost::regex("unsafe")},
        {Token::kUse, boost::regex("use")},
        {Token::kWhere, boost::regex("where")},
        {Token::kWhile, boost::regex("while")},
        {Token::kDyn, boost::regex("dyn")},

        {Token::kIdentifier, boost::regex("[a-zA-Z][a-zA-Z0-9_]*")},

        // {Token::kComment, boost::regex("((//([^\\n])*(\\n)?)|(\\/\\*[\\s\\S]*\\*\\/))")},

        {Token::kCharLiteral, boost::regex(R"('([^'\\\n\r\t]|\\'|\\"|\\x[0-7][0-9a-fA-F]|\\n|\\r|\\t|\\\\|\\0)')")},
        {Token::kStringLiteral, boost::regex(R"("(([^"\\\r\t])|(\\')|(\\")|((\\x[0-7][0-9a-fA-F])|(\\n)|(\\r)|(\\t)|(\\\\)|(\\0))|(\\\n))*"([a-zA-Z][a-zA-Z0-9_]*)?)")},
        {Token::kRawStringLiteral, boost::regex(R"(r([#]+)([^\r])*?(\1))")},
        {Token::kCStringLiteral, boost::regex(R"(c"(([^"\\\r\0])|(\\x[0-7][0-9a-fA-F])|(\\n)|(\\r)|(\\t)|\\\\|(\\\n))*")")},
        {Token::kRawCStringLiteral, boost::regex(R"(cr([#]+)([^\r\0])*?(\1))")},
        {Token::kIntegerLiteral, boost::regex("((0b[0-1_]*[0-1][0-1_]*)|(0o[0-7_]*[0-7][0-7_]*)|(0x[0-9a-fA-F_]*[0-9a-fA-F][0-9a-fA-F_]*)|([0-9][0-9_]*))((u32)|(i32)|(usize)|(isize))?")},

        {Token::kPlus, boost::regex(R"(\+)")},
        {Token::kMinus, boost::regex("-")},
        {Token::kStar, boost::regex(R"(\*)")},
        {Token::kSlash, boost::regex(R"(/)")},
        {Token::kPercent, boost::regex(R"(%)")},
        {Token::kCaret, boost::regex(R"(\^)")},
        {Token::kNot, boost::regex(R"(!)")},
        {Token::kAnd, boost::regex(R"(&)")},
        {Token::kOr, boost::regex(R"(\|)")},
        {Token::kAndAnd, boost::regex(R"(&&)")},
        {Token::kOrOr, boost::regex(R"(\|\|)")},
        {Token::kShl, boost::regex(R"(<<)")},
        {Token::kShr, boost::regex(R"(>>)")},
        {Token::kPlusEq, boost::regex(R"(\+=)")},
        {Token::kMinusEq, boost::regex(R"(-=)")},
        {Token::kStarEq, boost::regex(R"(\*=)")},
        {Token::kSlashEq, boost::regex(R"(/=)")},
        {Token::kPercentEq, boost::regex(R"(%=)")},
        {Token::kCaretEq, boost::regex(R"(\^=)")},
        {Token::kAndEq, boost::regex(R"(&=)")},
        {Token::kOrEq, boost::regex(R"(\|=)")},
        {Token::kShlEq, boost::regex(R"(<<=)")},
        {Token::kShrEq, boost::regex(R"(>>=)")},
        {Token::kEq, boost::regex(R"(=)")},
        {Token::kEqEq, boost::regex(R"(==)")},
        {Token::kNe, boost::regex(R"(!=)")},
        {Token::kGt, boost::regex(R"(>)")},
        {Token::kLt, boost::regex(R"(<)")},
        {Token::kGe, boost::regex(R"(>=)")},
        {Token::kLe, boost::regex(R"(<=)")},
        {Token::kAt, boost::regex(R"(@)")},
        {Token::kUnderscore, boost::regex(R"(_)")},
        {Token::kDot, boost::regex(R"(\.)")},
        {Token::kDotDot, boost::regex(R"(\.\.)")},
        {Token::kDotDotDot, boost::regex(R"(\.\.\.)")},
        {Token::kDotDotEq, boost::regex(R"(\.\.=)")},
        {Token::kComma, boost::regex(R"(,)")},
        {Token::kSemi, boost::regex(R"(;)")},
        {Token::kColon, boost::regex(R"(:)")},
        {Token::kPathSep, boost::regex(R"(::)")},
        {Token::kRArrow, boost::regex(R"(->)")},
        {Token::kFatArrow, boost::regex(R"(=>)")},
        {Token::kLArrow, boost::regex(R"(<-)")},
        {Token::kPound, boost::regex(R"(#)")},
        {Token::kDollar, boost::regex(R"(\$)")},
        {Token::kQuestion, boost::regex(R"(\?)")},
        {Token::kTilde, boost::regex(R"(~)")},

        {Token::kLCurly, boost::regex(R"(\{)")},
        {Token::kRCurly, boost::regex(R"(\})")},
        {Token::kLSquare, boost::regex(R"(\[)")},
        {Token::kRSquare, boost::regex(R"(\])")},
        {Token::kLParenthese, boost::regex(R"(\()")},
        {Token::kRParenthese, boost::regex(R"(\))")},
    };
public:
    std::vector<std::pair<Token, std::string>> lex(std::string);
};

std::string tokenToString(Token token);