#pragma once

#include <regex>

enum class Token {
    // strict keywords
    kAs,
    kBreak,
    kConst,
    kContinue,
    kCrate,
    kElse,
    kEnum,
    kFalse,
    kFn,
    kFor,
    kIf,
    kImpl,
    kIn,
    kLet,
    kLoop,
    kMatch,
    kMod,
    kMove,
    kMut,
    // kPub, do not need to implement
    kRef,
    kReturn,
    kSelf, // self
    kSelf_, // Self
    kStatic,
    kStruct,
    kSuper,
    kTrait,
    kTrue,
    kType,
    kUnsafe,
    kUse,
    kWhere,
    kWhile,
    kDyn,

    // identifier
    kIdentifier,

    // comments
    kComment,

    // literals
    kCharLiteral,
    kStringLiteral,
    kRawStringLiteral,
    kCStringLiteral,
    kRawCStringLiteral,
    kIntegerLiteral,

    // punctuations
    kPlus,
    kMinus,
    kStar,
    kSlash,
    kPercent,
    kCaret,
    kNot,
    kAnd,
    kOr,
    kAndAnd,
    kOrOr,
    kShl,
    kShr,
    kPlusEq,
    kMinusEq,
    kStarEq,
    kSlashEq,
    kPercentEq,
    kCaretEq,
    kAndEq,
    kOrEq,
    kShlEq,
    kShrEq,
    kEq,
    kEqEq,
    kNe,
    kGt,
    kLt,
    kGe,
    kLe,
    kAt,
    kUnderscore,
    kDot,
    kDotDot,
    kDotDotDot,
    kDotDotEq,
    kComma,
    kSemi,
    kColon,
    kPathSep,
    kRArrow,
    kFatArrow,
    kLArrow,
    kPound,
    kDollar,
    kQuestion,
    kTilde,

    // delimiters
    kLCurly,
    kRCurly,
    kLSquare,
    kRSquare,
    kLParenthese,
    kRParenthese,

    kEOF,
};

class Lexer {
private:
    std::vector<std::pair<Token, std::regex>> patterns = {
        {Token::kAs, std::regex("as")},
        {Token::kBreak, std::regex("break")},
        {Token::kConst, std::regex("const")},
        {Token::kContinue, std::regex("continue")},
        {Token::kCrate, std::regex("crate")},
        {Token::kElse, std::regex("else")},
        {Token::kEnum, std::regex("enum")},
        {Token::kFalse, std::regex("false")},
        {Token::kFn, std::regex("fn")},
        {Token::kFor, std::regex("for")},
        {Token::kIf, std::regex("if")},
        {Token::kImpl, std::regex("impl")},
        {Token::kIn, std::regex("in")},
        {Token::kLet, std::regex("let")},
        {Token::kLoop, std::regex("loop")},
        {Token::kMatch, std::regex("match")},
        {Token::kMod, std::regex("mod")},
        {Token::kMove, std::regex("move")},
        {Token::kMut, std::regex("mut")},
        {Token::kRef, std::regex("ref")},
        {Token::kReturn, std::regex("return")},
        {Token::kSelf, std::regex("self")},
        {Token::kSelf_, std::regex("Self")},
        {Token::kStatic, std::regex("static")},
        {Token::kStruct, std::regex("struct")},
        {Token::kSuper, std::regex("super")},
        {Token::kTrait, std::regex("trait")},
        {Token::kTrue, std::regex("true")},
        {Token::kType, std::regex("type")},
        {Token::kUnsafe, std::regex("unsafe")},
        {Token::kUse, std::regex("use")},
        {Token::kWhere, std::regex("where")},
        {Token::kWhile, std::regex("while")},
        {Token::kDyn, std::regex("dyn")},

        {Token::kIdentifier, std::regex("[a-zA-Z][a-zA-Z0-9_]*")},

        {Token::kComment, std::regex("((//([^\\n])*(\\n)?)|(\\/\\*[\\s\\S]*\\*/))")},

        {Token::kCharLiteral, std::regex(R"('([^'\\\n\r\t]|\\'|\\"|\\x[0-7][0-9a-fA-F]|\\n|\\r|\\t|\\\\|\\0)')")},
        {Token::kStringLiteral, std::regex(R"("(([^"\\\r\t])|(\\')|(\\")|((\\x[0-7][0-9a-fA-F])|(\\n)|(\\r)|(\\t)|(\\\\)|(\\0))|(\\\n))*"([a-zA-Z][a-zA-Z0-9_]*)?)")},
        {Token::kRawStringLiteral, std::regex(R"(r([#]+)([^\r])*?(\1))")},
        {Token::kCStringLiteral, std::regex(R"(c"(([^"\\\r\0])|(\\x[0-7][0-9a-fA-F])|(\\n)|(\\r)|(\\t)|\\\\|(\\\n))*")")},
        {Token::kRawCStringLiteral, std::regex(R"(cr([#]+)([^\r\0])*?(\1))")},
        {Token::kIntegerLiteral, std::regex("((0b[0-1_]*[0-1][0-1_]*)|(0o[0-7_]*[0-7][0-7_]*)|(0x[0-9a-fA-F_]*[0-9a-fA-F][0-9a-fA-F_]*)|([0-9][0-9_]*))((u32)|(i32)|(usize)|(isize))?")},

        {Token::kPlus, std::regex(R"(\+)")},
        {Token::kMinus, std::regex("-")},
        {Token::kStar, std::regex(R"(\*)")},
        {Token::kSlash, std::regex(R"(/)")},
        {Token::kPercent, std::regex(R"(%)")},
        {Token::kCaret, std::regex(R"(\^)")},
        {Token::kNot, std::regex(R"(!)")},
        {Token::kAnd, std::regex(R"(&)")},
        {Token::kOr, std::regex(R"(\|)")},
        {Token::kAndAnd, std::regex(R"(&&)")},
        {Token::kOrOr, std::regex(R"(\|\|)")},
        {Token::kShl, std::regex(R"(<<)")},
        {Token::kShr, std::regex(R"(>>)")},
        {Token::kPlusEq, std::regex(R"(\+=)")},
        {Token::kMinusEq, std::regex(R"(-=)")},
        {Token::kStarEq, std::regex(R"(\*=)")},
        {Token::kSlashEq, std::regex(R"(/=)")},
        {Token::kPercentEq, std::regex(R"(%=)")},
        {Token::kCaretEq, std::regex(R"(\^=)")},
        {Token::kAndEq, std::regex(R"(&=)")},
        {Token::kOrEq, std::regex(R"(\|=)")},
        {Token::kShlEq, std::regex(R"(<<=)")},
        {Token::kShrEq, std::regex(R"(>>=)")},
        {Token::kEq, std::regex(R"(=)")},
        {Token::kEqEq, std::regex(R"(==)")},
        {Token::kNe, std::regex(R"(!=)")},
        {Token::kGt, std::regex(R"(>)")},
        {Token::kLt, std::regex(R"(<)")},
        {Token::kGe, std::regex(R"(>=)")},
        {Token::kLe, std::regex(R"(<=)")},
        {Token::kAt, std::regex(R"(@)")},
        {Token::kUnderscore, std::regex(R"(_)")},
        {Token::kDot, std::regex(R"(\.)")},
        {Token::kDotDot, std::regex(R"(\.\.)")},
        {Token::kDotDotDot, std::regex(R"(\.\.\.)")},
        {Token::kDotDotEq, std::regex(R"(\.\.=)")},
        {Token::kComma, std::regex(R"(,)")},
        {Token::kSemi, std::regex(R"(;)")},
        {Token::kColon, std::regex(R"(:)")},
        {Token::kPathSep, std::regex(R"(::)")},
        {Token::kRArrow, std::regex(R"(->)")},
        {Token::kFatArrow, std::regex(R"(=>)")},
        {Token::kLArrow, std::regex(R"(<-)")},
        {Token::kPound, std::regex(R"(#)")},
        {Token::kDollar, std::regex(R"(\$)")},
        {Token::kQuestion, std::regex(R"(\?)")},
        {Token::kTilde, std::regex(R"(~)")},

        {Token::kLCurly, std::regex(R"(\{)")},
        {Token::kRCurly, std::regex(R"(\})")},
        {Token::kLSquare, std::regex(R"(\[)")},
        {Token::kRSquare, std::regex(R"(\])")},
        {Token::kLParenthese, std::regex(R"(\()")},
        {Token::kRParenthese, std::regex(R"(\))")},
    };
public:
    std::vector<std::pair<Token, std::string>> lex(std::string);
};