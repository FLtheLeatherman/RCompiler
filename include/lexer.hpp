#pragma once

#include <regex>

enum class Token {
    // strict keywords
    kAs,
    kBreak,
    kConst,
    kContinue,
    kCrate,
    kElse,
    kEnum,
    kFalse,
    kFn,
    kFor,
    kIf,
    kImpl,
    kIn,
    kLet,
    kLoop,
    kMatch,
    kMod,
    kMove,
    kMut,
    // kPub, do not need to implement
    kRef,
    kReturn,
    kSelf, // self
    kSelf_, // Self
    kStatic,
    kStruct,
    kSuper,
    kTrait,
    kTrue,
    kType,
    kUnsafe,
    kUse,
    kWhere,
    kWhile,
    kDyn,

    // identifier
    kIdentifier,

    // comments
    kComment,

    // literals
    kCharLiteral,
    kStringLiteral,
    kRawStringLiteral,
    kCStringLiteral,
    kRawCStringLiteral,
    kIntegerLiteral,

    // punctuations
    kPlus,
    kMinus,
    kStar,
    kSlash,
    kPercent,
    kCaret,
    kNot,
    kAnd,
    kOr,
    kAndAnd,
    kOrOr,
    kShl,
    kShr,
    kPlusEq,
    kMinusEq,
    kStarEq,
    kSlashEq,
    kPercentEq,
    kCaretEq,
    kAndEq,
    kOrEq,
    kShlEq,
    kShrEq,
    kEq,
    kEqEq,
    kNe,
    kGt,
    kLt,
    kGe,
    kLe,
    kAt,
    kUnderscore,
    kDot,
    kDotDot,
    kDotDotDot,
    kDotDotEq,
    kComma,
    kSemi,
    kColon,
    kPathSep,
    kRArrow,
    kFatArrow,
    kLArrow,
    kPound,
    kDollar,
    kQuestion,
    kTilde,

    // delimiters
    kLCurly,
    kRCurly,
    kLSquare,
    kRSquare,
    kLParenthese,
    kRParenthese,
};

class Lexer {
private:
    std::vector<std::pair<Token, std::regex>> patterns = {
        {Token::kAs, std::regex("as")},
        {Token::kBreak, std::regex("break")},
        {Token::kConst, std::regex("const")},
        {Token::kContinue, std::regex("continue")},
        {Token::kCrate, std::regex("crate")},
        {Token::kElse, std::regex("else")},
        {Token::kEnum, std::regex("enum")},
        {Token::kFalse, std::regex("false")},
        {Token::kFn, std::regex("fn")},
        {Token::kFor, std::regex("for")},
        {Token::kIf, std::regex("if")},
        {Token::kImpl, std::regex("impl")},
        {Token::kIn, std::regex("in")},
        {Token::kLet, std::regex("let")},
        {Token::kLoop, std::regex("loop")},
        {Token::kMatch, std::regex("match")},
        {Token::kMod, std::regex("mod")},
        {Token::kMove, std::regex("move")},
        {Token::kMut, std::regex("mut")},
        {Token::kRef, std::regex("ref")},
        {Token::kReturn, std::regex("return")},
        {Token::kSelf, std::regex("self")},
        {Token::kSelf, std::regex("Self")},
        {Token::kStatic, std::regex("static")},
        {Token::kStruct, std::regex("struct")},
        {Token::kSuper, std::regex("super")},
        {Token::kTrait, std::regex("trait")},
        {Token::kTrue, std::regex("true")},
        {Token::kType, std::regex("type")},
        {Token::kUnsafe, std::regex("unsafe")},
        {Token::kUse, std::regex("use")},
        {Token::kWhere, std::regex("where")},
        {Token::kWhile, std::regex("while")},
        {Token::kDyn, std::regex("dyn")},

        {Token::kIdentifier, std::regex("[a-zA-Z][a-zA-Z0-9_]*")},

        {Token::kComment, std::regex("((//([^\\n])*(\\n)?)|(\\/\\*[\\s\\S]*\\*/))")},

        {Token::kCharLiteral, std::regex(R"('([^'\\\n\r\t]|\\'|\\"|\\x[0-7][0-9a-fA-F]|\\n|\\r|\\t|\\\\|\\0)')")},
        {Token::kStringLiteral, std::regex()},
    };
public:
    std::vector<std::pair<Token, std::string>> lex(std::string);
};